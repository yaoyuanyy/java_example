## 命令模式-command

 
#### 一.意图

- 将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作 

#### 二. 说明(动机)
```
  命令模式就是对命令的封装，首先来看一下命令模式类图中的基本结构：

Command类：是一个抽象类，类中对需要执行的命令进行声明，一般来说要对外公布一个execute方法用来执行命令。
ConcreteCommand类：Command类的实现类，对抽象类中声明的方法进行实现。
Client类：最终的客户端调用类。
以上三个类的作用应该是比较好理解的，下面我们重点说一下Invoker类和Recevier类。
Invoker类：调用者，负责调用命令。
Receiver类：接收者，负责接收命令并且执行命令。
  
  所谓对命令的封装，说白了，无非就是把一系列的操作写到一个方法中，然后供客户端调用就行了，反映到类图上，只需要一个ConcreteCommand类和Client类就可以完成对命令的封装，即使再进一步，为了增加灵活性，可以再增加一个Command类进行适当地抽象

```

#### 三. 分类

```

```
    
#### 四. 适用场景
```
需要对行为进行记录，撤销，重做，事务处理时
需要抽象出待执行的动作，然后以参数的形式提供出来
```
#### 五. 优缺点
```
1.优点：
降低对象之间的耦合度。调用者角色与接受者角色之间没有任何依赖关系，调用者实现功能时只需要调用Command抽象类的execute方法就可以，不需要知道到底是哪个接收者执行
新的命令可以很容易地加入到系统中。可扩展性，Command子类可以非常容易的扩展，而调用者Invoker和高层次的模块Client不产生严重的代码藕合
可以比较容易地设计一个组合命令
调用同一方法实现不同的功能

2.缺点：
使用命令模式可能会导致某些系统有过多的具体命令类。
因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。
```
#### 六. 实现例子
```markdown
饭店老板和厨师，店里来客人吃饭，老板命令厨师做菜的场景。老板是调用者，厨师是接受者，命令是命令对象
```

#### 七. 相关模式
```
```

#### 八. 参考
https://blog.csdn.net/zhengzhb/article/details/7550895