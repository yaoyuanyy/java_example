## 策略模式-strategy

 
#### 一.意图

定义一系列算法，把他们一个个封装起来，并且使他们可相互替换。本模式使得算法可独立于使用它的客户而变化。

#### 二. 说明(动机)
```

```

#### 三. 分类
```

```
    
#### 四. 适用场景

- 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
- 一个系统需要动态地在几种算法中选择一种。
- 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。

#### 五. 优缺点
```
策略模式的优点：
支持“开闭原则”，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为，提供了管理相关的算法族的办法。
可以避免使用多重条件语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。

策略模式的缺点：
必须对客户端（调用者）暴露所有的策略类，因为使用哪种策略是由客户端来决定的，因此，客户端应该知道有什么策略，并且了解各种策略之间的区别，否则，后果很严重。比如，客户端要使用一个容器，有链表实现的，也有数组实现的，客户端是不是也要明白链表和数组有什么区别？就这一点来说是有悖于迪米特法则的。
由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。
```

#### 六. 实现概述
```
现在的人们越来越喜欢出去旅游。现在，春天到了，kyler想从北京到江苏宿迁，可以有三种策略供他选择：飞机，火车，自驾
skyler是客户Client；出去旅游是Context；出行方式是Strategy; 飞机，火车，自驾是ConcreteStrategy,即具体的策略
实现见代码

```

#### 七. java tools和spring中的应用

Comparator接口的使用
```
抽象策略类 Comparator
public interface Comparator<T> {
    int compare(T o1, T o2);
    boolean equals(Object obj);
}

具体策略类 SortComparator
public class SortComparator implements Comparator {

    @Override
    public int compare(Object o1, Object o2) {
        Student student1 = (Student) o1;
        Student student2 = (Student) o2;
        return student1.getAge() - student2.getAge();
    }
}

策略模式上下文 Collections
List<Student> list = new ArrayList<>(3);
list.add( new Student("zhangsan" ,31));
list.add( new Student("lisi" ,30));
list.add( new Student("wangwu" ,35));
Collections. sort(list,new SortComparator());
System.out.println(list);
```

#### 八. 与其他模式对比和关联

vs工厂模式
```markdown
工厂模式是创建型模式 ，它关注对象创建，提供创建对象的接口. 让对象的创建与具体的使用客户无关。
策略模式是对象行为型模式 ，它关注行为和算法的封装 。
它定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。使得算法可独立于使用它的客户而变化。


```
vs模版方法模式
```markdown
模版方法模式也是关注对算法的封装，对照类图可以看到，
策略模式与模版方法模式的区别仅仅是多了一个单独的封装类Context，它与模版方法模式的区别在于：在模版方法模式中，调用算法的主体在抽象的父类中，
而在策略模式中，调用算法的主体则是封装到了封装类Context中，抽象策略Strategy一般是一个接口，目的只是为了定义规范，里面一般不包含逻辑。
其实，这只是通用实现，而在实际编程中，因为各个具体策略实现类之间难免存在一些相同的逻辑，
为了避免重复的代码，我们常常使用抽象类来担任Strategy的角色，在里面封装公共的代码，
因此，在很多应用的场景中，在策略模式中一般会看到模版方法模式的影子。

```